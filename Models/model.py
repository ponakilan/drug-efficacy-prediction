# -*- coding: utf-8 -*-
"""N_30_EL_MTR_ELM_SVR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TUCLy6tUSnedBmqJRQAgRRWkUWNGjRGm
"""

import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.metrics import root_mean_squared_error
from sklearn.preprocessing import StandardScaler
from sklearn.svm import NuSVR
import numpy as np
import math
def load_and_prepare_data(dataset_choice):
    if dataset_choice == "30":
        data = pd.read_csv("./dataset/N30ALL.csv")
    elif dataset_choice == "GAN":
        data = pd.read_csv("./dataset/N500_GAN.csv")
    else:
        data = pd.read_csv("./dataset/N_500_RELTF.csv")

    label = ["Paclitaxel", "Vincristine", "Daunorubicin", "Vinblastine", "Doxorubicin"]
    X = data.drop(columns=label)
    y = data[label]

    # Log transform targets
    y = y.applymap(lambda v: math.log10(v))

    # Correlation + Skewness filtering
    correlation = X.corr()
    high_corr_pair = [(correlation.index[i], correlation.columns[j])
                      for i in range(len(correlation.columns))
                      for j in range(i + 1, len(correlation.columns))
                      if correlation.iloc[i, j] > 0.8]
    high_corr_df = pd.DataFrame(high_corr_pair, columns=["Feature 1", "Feature 2"])
    skewness = data.skew()
    more_skewed, less_skewed = [], []
    for i, row in high_corr_df.iterrows():
        if skewness[row["Feature 1"]] > skewness[row["Feature 2"]]:
            more_skewed.append(row["Feature 1"])
            less_skewed.append(row["Feature 2"])
        else:
            more_skewed.append(row["Feature 2"])
            less_skewed.append(row["Feature 1"])

    # Log transform for less skewed
    X_new = X.copy()
    for col in less_skewed:
        X_new[col] = np.log10(X_new[col])

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X_new)

    return X,X_scaled, y, label, scaler



#X_scaled = StandardScaler().fit_transform(X_new)

def mlr_base_results(input,X_scaled,y,label):
  mlr_results = []
  MLR = LinearRegression()
  for drug in label:
    MLR.fit(X_scaled,y[drug])
    mlr_results.append(MLR.predict(input))

  mlr_results_df_1 = pd.DataFrame(mlr_results)
  mlr_results_df_1 = mlr_results_df_1.transpose()
  mlr_results_df_1.columns = label
  #mlr_results_df_1 = 10 ** mlr_results_df_1
  return mlr_results_df_1

#mlr_results_df = mlr_base_results(X_new)


def svr_base_results(input,X_scaled,y,label,scaler):
  scaler.transform(X_scaled)
  input= scaler.transform(input)
  svr_results = []
  for drug in label:
      svr_model = NuSVR(kernel="rbf", degree=3, gamma=0.15, C=18, nu=0.5)
      svr_model.fit(X_scaled, y[drug])
      svr_results.append(svr_model.predict(input))

  df_results_svr = pd.DataFrame(svr_results).T
  df_results_svr.columns = label
  df_results_svr = df_results_svr
  df_results_svr.index = ["Efficacy Values"]
  return df_results_svr



"""## NOVELTY"""


def res_prepare(X,label,mlr_results_df,X_scaled,y):
  residual_df = pd.DataFrame(columns=label)
  for i in range(y.shape[0]):
    for drug in label:
      residual = abs(y.iloc[i][drug] - mlr_results_df.iloc[i][drug])
      residual_df.loc[i,drug] = residual


  X_scaled_df = pd.DataFrame(X_scaled,columns=X.columns)
  residual_data_frame_entire = pd.concat([X_scaled_df,residual_df],axis=1)
  y_residue = residual_data_frame_entire[label]
  return y_residue

  
  


def predict_svr_residual(X,input,X_scaled,y,label):
  predicted_residuals = {}
  mlr_results_df = mlr_base_results(X_scaled,X_scaled,y,label)
  y_residue = res_prepare(X,label,mlr_results_df,X_scaled,y)
  svr_results_residue =[]
  svr_res_models = {}
  for drug in label:
    svr_model = NuSVR(kernel="rbf",
                degree=3,
                gamma=0.15,
                coef0=0,
                C=18,
                shrinking=True,
                tol=0.001,
                nu=0.5,
                )
    svr_model.fit(X_scaled,y_residue[drug])
    svr_res_models[drug] = svr_model
    svr_pred = svr_model.predict(X_scaled)
    svr_results_residue.append(svr_pred)
  for drug in label:
      predicted_residuals[drug] = svr_res_models[drug].predict(input)[0]

  # Convert to DataFrame
  residual_df = pd.DataFrame([predicted_residuals])

  # Predict MLR base (make sure mlr_results_df was computed from original training)
  mlr_pred = []
  for drug in label:
      model = LinearRegression()
      model.fit(X_scaled, y[drug])
      mlr_pred.append(model.predict(input)[0])
  mlr_df = pd.DataFrame([mlr_pred], columns=label)

  # Add residuals to MLR predictions
  final_prediction = mlr_df + residual_df
  final_prediction.columns = label
  final_prediction.index = ["Predicted Efficacy"]

  # Optionally back-transform from log if needed:
  final_prediction = 10 ** final_prediction

  return final_prediction






"""## RESIDUAL MODEL WITH XGBOOST"""

from xgboost import XGBRegressor
from sklearn.multioutput import MultiOutputRegressor

def predict_residual_xgboost(scaler,X,input_row,X_scaled,y,label):
  if input_row.ndim == 1:
    input_row = input_row.reshape(1, -1)
  input_row = scaler.transform(input_row)

  xgb = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=4, random_state=42)
  xgb_model = MultiOutputRegressor(xgb)
  mlr_results_df = mlr_base_results(X_scaled,X_scaled,y,label)
  y_residue = res_prepare(X,label,mlr_results_df,X_scaled,y)
  xgb_model.fit(X_scaled, y_residue)
  xgb_result = xgb_model.predict(input_row)
  xgb_result = pd.DataFrame(xgb_result,columns=label)
  mlr_pred = []
  for drug in label:
      model = LinearRegression()
      model.fit(X_scaled, y[drug])
      mlr_pred.append(model.predict(input_row)[0])
  mlr_df = pd.DataFrame([mlr_pred], columns=label)

  final_prediction = mlr_df + xgb_result
  final_prediction.columns = label
  final_prediction.index = ["Predicted Efficacy"]

  # Optionally back-transform from log if needed:
  final_prediction = 10 ** final_prediction

  return final_prediction



"""# Multi task NN"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Dense
from tensorflow.keras.optimizers import Adam
from sklearn.metrics import mean_squared_error


def multitasknn(input,label,scaler):
# Split
  input = scaler.transform(input)
  input_layer = Input(shape=(input.shape[1],))
  x = Dense(64, activation='relu')(input_layer)
  x = Dense(32, activation='relu')(x)

  # Output layers (one per drug)
  outputs = [Dense(1, name=drug)(x) for drug in label]

  # Build and compile model
  model = Model(inputs=input_layer, outputs=outputs)
  model.compile(optimizer=Adam(0.001), loss='mse')

  # Load trained weights
  model.load_weights('N30 EL MTR ELM SVR Model.weights.h5')

  # Predict
  predictions = model.predict(input)

  # Format predictions into DataFrame
  pred_values = np.round(np.hstack(predictions),4)  # shape: (1, 5)
  result_df = pd.DataFrame(pred_values, columns=label)

  return result_df



"""# LightGBM Regression"""

import pandas as pd
import numpy as np
from sklearn.metrics import mean_squared_error, r2_score
import lightgbm as lgb
from sklearn.model_selection import train_test_split

# Assuming X_scaled and y are already defined
def lightgbm(input,label,scaler):
    input = scaler.transform(input)
    predictions = {}
    models = {}
    for drug in label:
      models[drug] = lgb.Booster(model_file=f"{drug}_LightGBM.txt")

    for drug in label:
        model = models.get(drug)
        if model:
            pred = model.predict(input)
            predictions[drug] = pred[0]  # Take scalar from array
        else:
            predictions[drug] = np.nan  # Fallback if model missing

    return pd.DataFrame([predictions])